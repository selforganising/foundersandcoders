---
title: Testing
layout: seminar
---

#### Take a simple function

    def factorial(n):
        total = 1
        while n > 1: 
            total = total * n
            n = n - 1
        return total

#### Test method 1: call the function

Just call the function a few times with different values and observe the output:

    print factorial(0)
    print factorial(1)
    print factorial(2)
    print factorial(3)

Expect the output:

    1
    1
    2
    6


#### Test method 2: simple boolean tests

Create expressions that call the function and each time compare it to the expected output:

    print factorial(0) == 1
    print factorial(1) == 1
    print factorial(2) == 2
    print factorial(3) == 6

Expect:

    True
    True
    True
    True

If any of these tests return `False`, you will not know the value that they return and you will need to investigate further, but this introduces the idea of a test that either passes, returning `True`, or fails, returning `False`. Unlike the first test method, these are self-contained tests that tell you at a glance whether or not the function is returning the correct value.




#### Test method 3: Assertions

    assert factorial(0) == 1
    assert factorial(1) == 1
    assert factorial(2) == 2
    assert factorial(3) == 6

Assertions are actually used more commonly inside functions to test for errors, like this:

    def factorial(n):
        assert n >= 0
        total = 1
        while n > 1: 
            total = total * n
            n = n - 1
        return total

In this case, the program will terminate if you attempt to evaluate the factorial of a negative number.




#### Test method 3: The "Udacity" method

    def test():
        test_cases = [(0,1),
                      (1,1),
                      (2,2),
                      (3,6)]
        for (arg, answer) in test_cases:
            result = factorial(arg)
            if result != answer:
                print "Test with data:", arg, "failed with result ", result
            else:
                print "Test case passed!"

    test()

#### Test method 4: unittest

`unitest` is the standard Python unit testing framework.

    import unittest

    class FactorialTest(unittest.TestCase):
         def test(self):
	        self.assertEqual(factorial(0), 1)
	        self.assertEqual(factorial(1), 1)
	        self.assertEqual(factorial(2), 2)
	        self.assertEqual(factorial(3), 6)

    if __name__ == '__main__':
        unittest.main()

#### Test method 5: doctest

    def factorial(n):
        """Return the factorial of n, an exact integer >= 0

        >>> [factorial(n) for n in range(6)]
        [1, 1, 2, 6, 24, 120]
        """
        total = 1
        while n > 1:
            total = total * n
            n = n - 1
        return total

    if __name__ == "__main__":
        import doctest
        doctest.testmod()

#### Other methods

This quick summary does not even begin to exhaust the possible ways of testing in Python. Aa your codebase gets more complex, other testing libraries are available to help you manage that complexity. If you are curious, take a look at `py.test`, `nose`, `tox`, `unittest2` and `mock`.